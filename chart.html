<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Crypto Signals - Chart with Markers</title>
  <style>
    html,body { height:100%; margin:0; background:#0b1220; color:#fff; font-family:Arial,Helvetica,sans-serif; }
    #top { display:flex; align-items:center; gap:12px; padding:8px 12px; background:#071028; }
    #title { font-weight:700; }
    #controls { margin-left:auto; display:flex; gap:8px; align-items:center; }
    #chart { height: calc(100vh - 56px); }
    select,button { padding:6px 8px; font-size:14px; border-radius:6px; }
    .signal { font-weight:700; padding:6px 10px; border-radius:8px; }
    .buy { background:#0f7a2b; color:white; }
    .sell { background:#a11; color:white; }
  </style>
</head>
<body>
  <div id="top">
    <div style="display:flex;align-items:center;gap:8px">
      <img id="icon" src="icon.png" style="width:36px;height:36px;border-radius:6px"/>
      <div>
        <div id="title">Crypto Signals</div>
        <div style="font-size:11px;color:#a8b3c7">EMA(14/50) • RSI(14) • Volume</div>
      </div>
    </div>
    <div id="controls">
      <label for="sym">Symbol</label>
      <select id="sym"></select>
      <button id="refresh">Refresh</button>
      <div id="signalLabel" class="signal">--</div>
    </div>
  </div>

  <div id="chart"></div>

  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    // Top 10 USDT pairs
    const TOP = ["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","MATICUSDT","ADAUSDT","XRPUSDT","DOGEUSDT","DOTUSDT","AVAXUSDT"];
    const symSelect = document.getElementById('sym');
    TOP.forEach(s => { let o = document.createElement('option'); o.value = s; o.text = s.replace('USDT','/USDT'); symSelect.appendChild(o); });
    let selected = TOP[0];
    symSelect.value = selected;

    // Create chart
    const chartContainer = document.getElementById('chart');
    const chart = LightweightCharts.createChart(chartContainer, {
      layout: { backgroundColor: '#0b1220', textColor: '#d0d7e0' },
      grid: { vertLines: { color: '#132230' }, horzLines: { color: '#132230' } },
      timeScale: { timeVisible: true, secondsVisible: false }
    });
    const candleSeries = chart.addCandlestickSeries();
    const ema14Series = chart.addLineSeries({ lineWidth:2, priceFormat: { type: 'price' } });
    const ema50Series = chart.addLineSeries({ lineWidth:2, priceFormat: { type: 'price' } });

    // Fetch klines from Binance
    async function fetchKlines(symbol, interval='1m', limit=300){
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const resp = await fetch(url);
      if(!resp.ok) throw new Error('Fetch klines failed: ' + resp.status);
      const data = await resp.json();
      return data.map(d=>({
        time: Math.floor(d[0]/1000),
        open: parseFloat(d[1]),
        high: parseFloat(d[2]),
        low: parseFloat(d[3]),
        close: parseFloat(d[4]),
        volume: parseFloat(d[5])
      }));
    }

    // EMA calculation (standard)
    function calcEMA(values, period){
      if(values.length === 0) return [];
      const k = 2/(period+1);
      let ema = [];
      let prev = values[0];
      ema.push(prev);
      for(let i=1;i<values.length;i++){
        prev = values[i]*k + prev*(1-k);
        ema.push(prev);
      }
      return ema;
    }

    // RSI calculation (Wilder)
    function calcRSI(closes, period=14){
      let rsis = Array(closes.length).fill(null);
      if(closes.length <= period) return rsis;
      let gains=0, losses=0;
      for(let i=1;i<=period;i++){
        const diff = closes[i]-closes[i-1];
        if(diff>0) gains += diff; else losses += Math.abs(diff);
      }
      let avgGain = gains/period, avgLoss = losses/period;
      rsis[period] = 100 - (100/(1 + (avgGain/(avgLoss||1e-9))));
      for(let i=period+1;i<closes.length;i++){
        const diff = closes[i]-closes[i-1];
        const gain = diff>0?diff:0;
        const loss = diff<0?Math.abs(diff):0;
        avgGain = (avgGain*(period-1) + gain)/period;
        avgLoss = (avgLoss*(period-1) + loss)/period;
        const rs = avgGain/(avgLoss||1e-9);
        rsis[i] = 100 - (100/(1+rs));
      }
      return rsis;
    }

    // Update chart + compute indicators + set markers
    async function update(symbol){
      try{
        document.getElementById('signalLabel').innerText = 'Loading...';
        const klines = await fetchKlines(symbol, '1m', 300);
        if(!klines || klines.length===0) throw new Error('No klines');
        // candle data
        const candles = klines.map(k => ({ time: k.time, open: k.open, high: k.high, low: k.low, close: k.close }));
        candleSeries.setData(candles);

        // closes array
        const closes = klines.map(k=>k.close);

        // EMAs
        const ema14 = calcEMA(closes, 14);
        const ema50 = calcEMA(closes, 50);
        // Align EMA arrays to time indexes
        const ema14Points = ema14.map((v,i)=>({ time: klines[i].time, value: Number(v.toFixed(8)) }));
        const ema50Points = ema50.map((v,i)=>({ time: klines[i].time, value: Number(v.toFixed(8)) }));
        ema14Series.setData(ema14Points);
        ema50Series.setData(ema50Points);

        // RSI
        const rsi = calcRSI(closes, 14);

        // Avg volume
        const vols = klines.map(k=>k.volume);
        const avgVol = vols.reduce((a,b)=>a+b,0)/vols.length;

        // Decide signal for last candle
        const lastIdx = klines.length-1;
        const last = klines[lastIdx];
        const lastEMA14 = ema14[lastIdx];
        const lastEMA50 = ema50[lastIdx];
        const lastRSI = rsi[lastIdx];
        let signal = 'HOLD';
        if(last.close > lastEMA50 && lastEMA14 > lastEMA50 && lastRSI>35 && lastRSI<70 && last.volume>avgVol) signal = 'STRONG BUY';
        else if(last.close < lastEMA50 && lastEMA14 < lastEMA50 && lastRSI<40) signal = 'STRONG SELL';
        document.getElementById('signalLabel').innerText = signal;
        document.getElementById('signalLabel').className = 'signal ' + (signal.includes('BUY')? 'buy' : signal.includes('SELL')? 'sell' : '');

        // Build markers array: EMA crossovers (recent) + RSI extremes
        let markers = [];
        // EMA crossovers in last N candles
        const lookback = 80;
        for(let i=Math.max(1, ema14.length - lookback); i<ema14.length; i++){
          if(ema14[i-1] <= ema50[i-1] && ema14[i] > ema50[i]){
            markers.push({ time: klines[i].time, position: 'aboveBar', color: 'green', shape: 'arrowUp', text: 'EMA Buy' });
          } else if(ema14[i-1] >= ema50[i-1] && ema14[i] < ema50[i]){
            markers.push({ time: klines[i].time, position: 'belowBar', color: 'red', shape: 'arrowDown', text: 'EMA Sell' });
          }
        }
        // RSI extremes markers
        for(let i=0;i<rsi.length;i++){
          if(rsi[i] !== null && rsi[i] < 25){
            markers.push({ time: klines[i].time, position: 'aboveBar', color: 'green', shape: 'arrowUp', text: 'RSI Buy' });
          } else if(rsi[i] !== null && rsi[i] > 75){
            markers.push({ time: klines[i].time, position: 'belowBar', color: 'red', shape: 'arrowDown', text: 'RSI Sell' });
          }
        }

        // Remove duplicate markers at same time preferring EMA marker
        const uniq = {};
        markers.forEach(m => {
          const key = m.time + '|' + m.position;
          if(!uniq[key]) uniq[key] = m;
        });
        const finalMarkers = Object.values(uniq);

        candleSeries.setMarkers(finalMarkers);
      } catch(err){
        console.error(err);
        document.getElementById('signalLabel').innerText = 'Error';
      }
    }

    document.getElementById('refresh').addEventListener('click', ()=> update(symSelect.value));
    symSelect.addEventListener('change', ()=> update(symSelect.value));

    // initial load and periodic refresh every 10s
    update(selected);
    setInterval(()=> update(symSelect.value), 10000);

    // handle resize
    window.addEventListener('resize', ()=> chart.applyOptions({ width: chartContainer.clientWidth, height: chartContainer.clientHeight }));
  })();
  </script>
</body>
</html>
