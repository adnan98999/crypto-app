<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CryptoSignals - Live Chart</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    #top { padding: 8px; background: #0b2545; color: white; display:flex; align-items:center; gap:8px; }
    #controls { margin-left: auto; display:flex; gap:8px; align-items:center; }
    #chart { height: calc(100vh - 48px); }
    select, button { padding:6px 8px; font-size:14px; }
    .signal { font-weight:700; padding:6px 8px; border-radius:6px; }
    .buy { background:#0f7a2b; color:white; }
    .sell { background:#a11; color:white; }
  </style>
</head>
<body>
  <div id="top">
    <div style="display:flex;align-items:center;gap:8px">
      <img src="bin/icon.png" style="width:36px;height:36px;border-radius:6px" />
      <div><strong>Crypto Signals</strong><div style="font-size:12px">EMA(14/50) + RSI(14) + Volume</div></div>
    </div>
    <div id="controls">
      <label for="sym">Symbol</label>
      <select id="sym"></select>
      <button id="refresh">Refresh</button>
      <div id="signalLabel" class="signal">--</div>
    </div>
  </div>
  <div id="chart"></div>

  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    const TOP = ["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","MATICUSDT","ADAUSDT","XRPUSDT","DOGEUSDT","DOTUSDT","AVAXUSDT"];
    const symSelect = document.getElementById('sym');
    TOP.forEach(s=>{ let o=document.createElement('option'); o.value=s; o.text=s.replace('USDT','/USDT'); symSelect.appendChild(o); });
    let selected = TOP[0];
    symSelect.value = selected;

    const chartContainer = document.getElementById('chart');
    const chart = LightweightCharts.createChart(chartContainer, {
      width: chartContainer.clientWidth,
      height: chartContainer.clientHeight,
      layout: { backgroundColor: '#ffffff', textColor: '#000' }
    });
    const candleSeries = chart.addCandlestickSeries();
    const ema14Series = chart.addLineSeries({ priceLineVisible: false });
    const ema50Series = chart.addLineSeries({ priceLineVisible: false });
    let markers = [];

    function resize(){ chart.applyOptions({ width: chartContainer.clientWidth, height: chartContainer.clientHeight }); }
    window.addEventListener('resize', resize);

    async function fetchKlines(symbol, interval='1m', limit=200){
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const resp = await fetch(url);
      if(!resp.ok) throw new Error('Klines fetch failed: ' + resp.status);
      const data = await resp.json();
      return data.map(d=>({
        time: Math.floor(d[0]/1000),
        open: parseFloat(d[1]),
        high: parseFloat(d[2]),
        low: parseFloat(d[3]),
        close: parseFloat(d[4]),
        volume: parseFloat(d[5])
      }));
    }

    function calcEMA(values, period){
      const k = 2/(period+1);
      let ema = [];
      let prev = values[0];
      ema.push(prev);
      for(let i=1;i<values.length;i++){
        const v = (values[i]*k) + (prev*(1-k));
        prev = v;
        ema.push(v);
      }
      return ema;
    }
    function calcRSI(closes, period=14){
      let gains=0, losses=0;
      for(let i=1;i<=period;i++){
        const diff = closes[i]-closes[i-1];
        if(diff>0) gains+=diff; else losses+=Math.abs(diff);
      }
      let avgGain = gains/period, avgLoss=losses/period;
      let rs = avgGain/(avgLoss||1e-9);
      let rsi = 100 - (100/(1+rs));
      let out = Array(period+1).fill(null);
      out.push(rsi);
      for(let i=period+1;i<closes.length;i++){
        const diff = closes[i]-closes[i-1];
        const gain = diff>0?diff:0;
        const loss = diff<0?Math.abs(diff):0;
        avgGain = (avgGain*(period-1) + gain)/period;
        avgLoss = (avgLoss*(period-1) + loss)/period;
        rs = avgGain/(avgLoss||1e-9);
        rsi = 100 - (100/(1+rs));
        out.push(rsi);
      }
      while(out.length < closes.length) out.unshift(null);
      return out.slice(-closes.length);
    }

    async function update(symbol){
      try{
        document.getElementById('signalLabel').innerText = 'Loading...';
        const klines = await fetchKlines(symbol,'1m',200);
        const candlesticks = klines.map(k=>({ time: k.time, open: k.open, high: k.high, low: k.low, close: k.close }));
        candleSeries.setData(candlesticks);
        const closes = klines.map(k=>k.close);
        const ema14 = calcEMA(closes,14);
        const ema50 = calcEMA(closes,50);
        const ema14Points = ema14.map((v,i)=>({ time: klines[i].time, value: Number(v.toFixed(6)) }));
        const ema50Points = ema50.map((v,i)=>({ time: klines[i].time, value: Number(v.toFixed(6)) }));
        ema14Series.setData(ema14Points);
        ema50Series.setData(ema50Points);
        const rsi = calcRSI(closes,14);
        const vols = klines.map(k=>k.volume);
        const avgVol = vols.reduce((a,b)=>a+b,0)/vols.length;
        const last = klines[klines.length-1];
        const lastEMA14 = ema14[ema14.length-1];
        const lastEMA50 = ema50[ema50.length-1];
        const lastRSI = rsi[rsi.length-1];
        let signal = 'HOLD';
        if(last.close > lastEMA50 && lastEMA14 > lastEMA50 && lastRSI>35 && lastRSI<70 && last.volume>avgVol) signal = 'STRONG BUY';
        else if(last.close < lastEMA50 && lastEMA14 < lastEMA50 && lastRSI<40) signal = 'STRONG SELL';
        document.getElementById('signalLabel').innerText = signal;
        document.getElementById('signalLabel').className = 'signal ' + (signal.includes('BUY')? 'buy' : signal.includes('SELL')? 'sell' : '');

        markers = [];
        for(let i=Math.max(1,ema14.length-50); i<ema14.length; i++){
          if(i<=0) continue;
          if(ema14[i-1] <= ema50[i-1] && ema14[i] > ema50[i]){
            markers.push({ time: klines[i].time, position: 'aboveBar', color: 'green', shape: 'arrowUp', text: 'Buy' });
          } else if(ema14[i-1] >= ema50[i-1] && ema14[i] < ema50[i]){
            markers.push({ time: klines[i].time, position: 'belowBar', color: 'red', shape: 'arrowDown', text: 'Sell' });
          }
        }
        for(let i=0;i<rsi.length;i++){
          if(rsi[i] !== null && rsi[i] < 25){
            markers.push({ time: klines[i].time, position: 'aboveBar', color: 'green', shape: 'arrowUp', text: 'RSI Buy' });
          } else if(rsi[i] !== null && rsi[i] > 75){
            markers.push({ time: klines[i].time, position: 'belowBar', color: 'red', shape: 'arrowDown', text: 'RSI Sell' });
          }
        }
        candleSeries.setMarkers(markers);
      } catch(err){
        console.error(err);
        document.getElementById('signalLabel').innerText = 'Error';
      }
    }

    document.getElementById('refresh').addEventListener('click', ()=> update(symSelect.value));
    symSelect.addEventListener('change', ()=> update(symSelect.value));
    update(selected);
    setInterval(()=> update(symSelect.value), 10000);
  })();
  </script>
</body>
</html>
